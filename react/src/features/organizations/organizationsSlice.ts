import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import { getAllOrganizations, updateOrganization, createOrganization } from './organizationsAPI';

interface Organization {
  id?: number,
  name: string,
  code: string,
  address: string,
  contactName: string,
  contactInfo: string
}
interface IActionUpdateField {
  id: number,
  key: string,
  value: string
}
export interface OrganizationsState {
  organizations: Organization[],
  selectedId: number,
  status: 'idle' | 'loading' | 'failed';
}

const initialState: OrganizationsState = {
  organizations: [],
  selectedId: 0,
  status: 'idle',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getOrganizationsAsync = createAsyncThunk(
  'organizations/getOrganizations',
  async () => {
    const response = await getAllOrganizations();
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "getAll"
    };
  }
);

export const updateOrganizationAsync = createAsyncThunk(
  'organizations/updateOrganization',
  async ( organization: Organization ) => {
    const id = organization.id;
    let org = {...organization};
    delete org.id;
    if(id) {
      const response = await updateOrganization(org, id);
      // The value we return becomes the `fulfilled` action payload
      return response.data;
    }   
  }
);

export const createOrganizationAsync = createAsyncThunk(
  'organizations/createOrganization',
  async ( organization: Organization ) => {
    let org = {...organization};
    delete org.id;
    const response = await createOrganization(org);
    // The value we return becomes the `fulfilled` action payload
    return response.data;
  }
);

export const organizationsSlice = createSlice({
  name: 'organizations',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    updateField: (state, action: PayloadAction<IActionUpdateField>) => {
      state.organizations = state.organizations.map( organization => {
        if(organization.id === action.payload.id) {
          return {
            ...organization,
            [action.payload.key]: action.payload.value
          };
        } else {
          return organization;
        }
      });
    },
    selectIdOrganization: (state, action: PayloadAction<number>) => {
      state.selectedId = action.payload
      if(action.payload === 0){
        state.organizations = [...state.organizations.filter( item => item.id ), {
          id: 0,
          name: "New Item",
          code: "",
          address: "",
          contactName: "",
          contactInfo: "",
        }]
      } else {
        state.organizations = state.organizations.filter( item => item.id )
      }
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getOrganizationsAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(getOrganizationsAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.organizations = action.payload.data.slice();
        if(action.payload.data.length > 0){
          state.selectedId = action.payload.data[0].id
        }
      })
      .addCase(getOrganizationsAsync.rejected, (state) => {
        state.status = 'failed';
      })
      .addCase(updateOrganizationAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(updateOrganizationAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.organizations = state.organizations.map( organization => {
          if(organization.id === action.payload.id) {
            return {
              ...action.payload
            };
          } else {
            return organization;
          }
        });
      })
      .addCase(updateOrganizationAsync.rejected, (state) => {
        state.status = 'failed';
      })
      .addCase(createOrganizationAsync.pending, (state) => {
        state.status = 'loading';
      })
      .addCase(createOrganizationAsync.fulfilled, (state, action) => {
        state.status = 'idle';
        state.organizations = [...state.organizations, action.payload].filter( item => item.id );
      })
      .addCase(createOrganizationAsync.rejected, (state) => {
        state.status = 'failed';
      });
  },
});

export const { updateField, selectIdOrganization } = organizationsSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectOrganizations = (state: RootState) => state.organizations.organizations;
export const selectSelectedId = (state: RootState) => state.organizations.selectedId;


export default organizationsSlice.reducer;
